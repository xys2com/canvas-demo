<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="Pragma" content="no-cache" />
    <meta http-equiv="Cache-Control" content="no-cache" />
    <meta http-equiv="Expires" content="0" />
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
    <meta
      name="viewport"
      content="width=device-width,initial-scale=1.0,user-scalable=no"
    />
    <style type="text/css">
      canvas {
        position: absolute;
        left: 0;
        top: 0;
      }
    </style>
  </head>
  <body bgcolor="#000000">
    <canvas id="tree"></canvas>
    <canvas id="flower"></canvas>
    <script src="./color-hex.js"></script>
    <script>
      const random = function (min, max) {
        if ((arguments.length < 2 && ((max = min), (min = 0)), min > max)) {
          let a = max;
          (max = min), (min = a);
        }
        const r = +min % 1 != 0 || +max % 1 != 0;
        if (r) {
          min *= 100000000;
          max *= 100000000;
        }
        return (
          (Math.floor(Math.random() * (max - min + 1)) + min) /
          (r ? 100000000 : 1)
        );
      };
      function dot(ctx, x, y) {
        ctx.save();
        ctx.beginPath();
        ctx.moveTo(x, y);
        ctx.arc(x, y, 1, 0, Math.PI * 2);
        ctx.fillStyle = "#f00";
        ctx.fill();
        ctx.closePath();
        ctx.restore();
      }
      //两个canvas
      let tree = document.getElementById("tree");
      tree.width = window.innerWidth;
      tree.height = window.innerHeight;
      let tCtx = tree.getContext("2d");
      let flower = document.getElementById("flower");
      flower.width = window.innerWidth;
      flower.height = window.innerHeight;
      let ctx = flower.getContext("2d");

      let flowerList = []; //樱花列表
      let rootTop = window.innerHeight; //树起点
      let flowerColor = "#ffc0cb34"; //花色
      let flowerColorDeep = "#f19ec24d"; //花色深
      let treeColor2 = "#ffc0cb4d"; //树枝颜色
      let treeColor = "#eee"; //树干颜色
      let fallList = []; //飘落樱花列表
      let g = 0.01; //重力加速度
      let gWind = 0.002; //风力加速度
      let limitSpeedY = 1; //速度上限
      let limitSpeedX = 1; //速度上限
      const totalStep = 32;

      // ctx.shadowColor = "#FFF";
      // ctx.shadowBlur = 5;
      let count = 0;
      function drawTree(x, y, deg, step, type) {
        let deg1 = (random(0, 100) % 2 == 0 ? 1 : -1) * random(0.01, 0.3);
        let x1 =
          x + Math.cos(deg + deg1) * (step + random(2, 5)) * random(0.8, 2.4); //以步长来判断枝干长度 x轴偏移大一些
        let y1 =
          y +
          (Math.sin(deg + deg1) * (step - random(0.5, 1)) * random(0.8, 2.4) +
            totalStep / step);
        //以步长来判断枝干长度 Y轴压缩一些
        tCtx.beginPath();
        tCtx.lineWidth = (step * Math.pow(2, step / 10)) / 10;
        // if (totalStep - step < 32) {
        //   console.log("x, y", x, y);
        //   console.log("x1, y1", x1, y1);
        //   setTimeout(() => {
        //     dot(tCtx, x, y);
        //   }, 50);
        // }
        tCtx.moveTo(x, y);
        tCtx.lineTo(x1, y1);
        count++;
        tCtx.closePath();
        tCtx.strokeStyle = step > 5 ? treeColor : treeColor2; //细纸条都换成花的颜色
        tCtx.stroke();
        if (step > 10) {
          //树干相交的位置有间隙，以一个圆填充
          tCtx.fillStyle = treeColor;
          tCtx.arc(x, y, tCtx.lineWidth / 2 + 1, 0, Math.PI * 2);
          tCtx.closePath();
          tCtx.fill();
        }
        if (step < 3 || (step < totalStep - 7 && Math.random() > 0.1)) {
          //末梢位置 画花瓣
          let color = [flowerColorDeep, flowerColor, flowerColor][
            Math.round(Math.random() + 0.2)
          ];
          let r = 2 + Math.random() * 2;
          ctx.beginPath();
          ctx.fillStyle = color;
          ctx.arc(
            x1 + Math.random() * 3,
            y1 + Math.random() * 3,
            r,
            0,
            Math.PI * 2
          );
          ctx.fill();
          ctx.closePath();
          flowerList.push({
            x: x,
            y: y,
            sx: Math.random() - 0.5,
            sy: 0,
            color: color,
            r: r,
            deg: deg,
          }); //保存下画樱花的位置
        }
        step--;
        if (step > 0) {
          drawTree(x1, y1, deg, step, type);
          if (
            step % 3 == 1 &&
            step > 0 &&
            step < totalStep - Math.floor(totalStep / 10)
          )
            drawTree(
              x1,
              y1,
              deg + 0.2 + 0.3 * Math.random(),
              Math.round(step / 1.13)
            ); //右分叉
          if (
            step % 3 == 0 &&
            step > 0 &&
            step < totalStep - Math.floor(totalStep / 10)
          )
            drawTree(
              x1,
              y1,
              deg - 0.2 - 0.3 * Math.random(),
              Math.round(step / 1.13)
            ); //左分叉
        }
      }

      drawTree(tree.width / 2, rootTop, -Math.PI / 2, totalStep, 1); //执行
      let len = flowerList.length;
      function step() {
        if (Math.random() > 0.3)
          fallList.push(flowerList[Math.floor(Math.random() * len)]); //随机取出一个，花瓣复制到飘落花瓣的列表中

        ctx.clearRect(0, 0, tree.width, tree.height);
        for (let i = 0; i < fallList.length; i++) {
          if (fallList[i].sy < limitSpeedY) fallList[i].sy += g;
          fallList[i].sx += gWind;
          fallList[i].x += fallList[i].sx;
          fallList[i].y += fallList[i].sy;
          if (fallList[i].y > rootTop) {
            //飘到树根的花瓣移除
            fallList.splice(i, 1);
            i--;
            continue;
          }
          ctx.beginPath();
          ctx.fillStyle = fallList[i].color;
          fallList[i].deg += fallList[i].sx * 0.05; //跟速度相关的旋转花瓣
          ctx.arc(
            fallList[i].x,
            fallList[i].y,
            fallList[i].r,
            fallList[i].deg,
            fallList[i].deg + Math.PI * 1.3
          );
          ctx.fill();
        }
        requestAnimationFrame(step);
      }
      // requestAnimationFrame(step);
    </script>
  </body>
</html>
