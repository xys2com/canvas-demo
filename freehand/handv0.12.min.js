function multiply(t,e,o){let s=e[0],i=e[1],n=e[2],r=e[3],l=e[4],a=e[5],h=e[6],c=e[7],p=e[8],y=e[9],f=e[10],d=e[11],x=e[12],m=e[13],u=e[14],g=e[15],P=o[0],C=o[1],M=o[2],v=o[3];return t[0]=P*s+C*l+M*p+v*x,t[1]=P*i+C*a+M*y+v*m,t[2]=P*n+C*h+M*f+v*u,t[3]=P*r+C*c+M*d+v*g,P=o[4],C=o[5],M=o[6],v=o[7],t[4]=P*s+C*l+M*p+v*x,t[5]=P*i+C*a+M*y+v*m,t[6]=P*n+C*h+M*f+v*u,t[7]=P*r+C*c+M*d+v*g,P=o[8],C=o[9],M=o[10],v=o[11],t[8]=P*s+C*l+M*p+v*x,t[9]=P*i+C*a+M*y+v*m,t[10]=P*n+C*h+M*f+v*u,t[11]=P*r+C*c+M*d+v*g,P=o[12],C=o[13],M=o[14],v=o[15],t[12]=P*s+C*l+M*p+v*x,t[13]=P*i+C*a+M*y+v*m,t[14]=P*n+C*h+M*f+v*u,t[15]=P*r+C*c+M*d+v*g,t}function calculateIntersection(t,e,o,s){let i=(t.x-o.x)*(e.y-o.y)-(t.y-o.y)*(e.x-o.x),n=(t.x-s.x)*(e.y-s.y)-(t.y-s.y)*(e.x-s.x);if(i*n>=0)return!1;let r=(o.x-t.x)*(s.y-t.y)-(o.y-t.y)*(s.x-t.x),l=r+i-n;if(r*l>=0)return!1;let a=r/(n-i),h=a*(e.x-t.x),c=a*(e.y-t.y);return{x:t.x+h,y:t.y+c}}function throttle(t,e){let o;return function(){let s=this,i=arguments;o||(o=setTimeout(function(){o=null,t.apply(s,i)},e))}}const random=function(t,e){if(arguments.length<2&&(e=t,t=0),t>e){let o=e;e=t,t=o}const o=+t%1!=0||+e%1!=0;return o&&(t*=1e8,e*=1e8),(Math.floor(Math.random()*(e-t+1))+t)/(o?1e8:1)},randomId=()=>Math.random().toString(32).slice(-8),isPointInPolygon=(t,e,o)=>{if(!e||!t)return!1;let s,i,n=e.length,r=!0,l=0,a=2e-10,h=t;s=e[0];for(let t=1;t<=n;++t){if(h.x==s.x&&h.y==s.y)return r;if(i=e[t%n],h.y<Math.min(s.y,i.y)||h.y>Math.max(s.y,i.y))s=i;else{if(h.y>Math.min(s.y,i.y)&&h.y<Math.max(s.y,i.y)){if(h.x<=Math.max(s.x,i.x)){if(s.y==i.y&&h.x>=Math.min(s.x,i.x))return r;if(s.x==i.x){if(s.x==h.x)return r;++l}else{let t=(h.y-s.y)*(i.x-s.x)/(i.y-s.y)+s.x;if(Math.abs(h.x-t)<a)return r;h.x<t&&++l}}}else if(h.y==i.y&&h.x<=i.x){let o=e[(t+1)%n];h.y>=Math.min(s.y,o.y)&&h.y<=Math.max(s.y,o.y)?++l:l+=2}s=i}}return l%2!=0},distance=(t,e)=>Math.sqrt((e.x-t.x)*(e.x-t.x)+(e.y-t.y)*(e.y-t.y)),slopeOffset=(t,e,o,s)=>t==o?random(5,50)/1e3:(s-e)/(o-t),slope=(t,e,o,s)=>(s-e)/(o-t),decimals=t=>+t%1,$isDOM=t=>"function"==typeof HTMLElement?t instanceof HTMLElement:t&&"object"==typeof t&&1===t.nodeType&&"string"==typeof t.nodeName,$=t=>{const e=document.querySelectorAll(t);return 1===e.length?e[0]:Array.from(e)};class HandDraw{constructor(t){const{x:e,y:o,width:s,height:i,el:n,zIndex:r,id:l,classname:a,colors:h={},pitchColors:c={}}=t,p=document.createElement("canvas"),y=l||randomId(),f=`canvas_id_${y}`,d=`ctx_id_${y}`,x=p.getContext("2d");p.setAttribute("id",f),p.style.position="absolute",p.style.zIndex=r,p.style.left=`${e}px`,p.style.top=`${o}px`,p.width=s,p.height=i,a&&p.classList.add(a),this.canvas=p,this.ctx=x,this.canvasSet=new Map,this.contextSet=new Map,this.canvasSet.set(f,p),this.contextSet.set(d,x),this.colors={side:h.side||"#fff",fill:h.fill||"#fff3",line:h.line||"#fff"},this.pitchColors={side:c.side||"#f00",fill:c.fill||"#f003",line:c.line||"#f008"},this.TOTALINDEX=0,this.lines=[],this.graph={polygon:{},circle:{},ellipse:{}},this.activeGraph={onmove:{},ontransform:{}},this.graphStatus=["ontransform","onenter","onpitch","onmove","onzoom"],this.activeStatus=["onmove","ontransform"];const m=n?$(n):document.body;m.appendChild(p)}}const COMMON={getCanvas(t){return t?this.canvasSet.get(t):this.canvas},getCtx(t){return t?this.contextSet.get(t):this.ctx},getGraph(t,e,o=""){const s=this.graph[t];let i=s[e];return o&&console.warn(t,e,o),i||(i={},i.index=this.getIndex(),i.id=e,i.zoom=1,i.ontransform=!1,i.onenter=!1,i.onpitch=!1,i.onmove=!1,i.onzoom=!1,i.lines=[],"polygon"==t&&(i.points=[]),"circle"==t&&(i.crosslines=[]),s[e]=i),s[e]},getPath(t,e){const o=this.graph[t];return o[e].path},dotin(t,e="#f00",o){const s=o||this.getCtx();s.save();const{x:i,y:n}=t;s.beginPath(),s.strokeStyle=e,s.fillStyle=e,s.arc(i,n,2,0,2*Math.PI),s.stroke(),s.fill(),s.closePath(),s.restore()},rectin(t,e,o,s,i="#00ff00",n){const r=n||this.getCtx();r.save(),r.beginPath(),r.moveTo(t,e),r.lineTo(t+o,e),r.lineTo(t+o,e+s),r.lineTo(t,e+s),r.lineTo(t,e),r.strokeStyle=i,r.stroke(),r.closePath(),r.restore()},getIndex(){return this.TOTALINDEX++,this.TOTALINDEX},clear(){this.ctx.clearRect(0,0,this.canvas.width,this.canvas.height)},scaleCommon(t){let{onlyPoint:e=!0,targetPoint:o,referPoint:s,targetRate:i,width:n,height:r}=t;const{x:l,y:a}=s,{x:h,y:c}=o;let p,y,f,d,x,m,u,g,P,C;n&&r||(e=!0),e?(p=l-l,y=a-a,f=h-l,d=c-a,p>f?(m=f,u=p):(m=p,u=f),y>d?(g=y,x=d):(g=d,x=y),P=p*(1-i),C=y*(1-i)):(m=h,u=h+n,x=c,g=c+r,P=l*(1-i),C=a*(1-i));const M=[m,x,1,1],v=[u,x,1,1],L=[u,g,1,1],b=[m,g,1,1];let T=new Float32Array([...M,...v,...L,...b]);const I=new Float32Array([0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]),S=[i,0,0,0],z=[0,i,0,0],G=[0,0,1,0],w=[P,C,0,1],D=new Float32Array([...S,...z,...G,...w]),O=multiply(I,D,T);if(e){let t,e;return t=p>f?O[0]+l:O[4]+l,e=y>d?O[1]+a:O[9]+a,{x:t,y:e}}return{width:O[4]-O[0],height:O[9]-O[1],left:O[0],right:O[4],top:O[1],bottom:O[9]}},refresh(t){this.clear(),this.refreshAllLine(t),this.refreshAllGraph(t),this.refreshAllCircles(t)},createCanvas(t,e){const{x:o,y:s,width:i,height:n,zIndex:r,id:l,classname:a}=t;try{const t=document.createElement("canvas"),h=l||randomId(),c=`canvas_id_${h}`,p=`ctx_id_${h}`,y=t.getContext("2d");this.canvasSet.set(c,t),this.contextSet.set(p,y),t.style.position="absolute",t.style.zIndex=r,t.style.left=`${o}px`,t.style.top=`${s}px`,t.width=i,t.height=n,a&&t.classList.add(a);const f=t.getContext("2d");return"function"==typeof e&&e(t,f,c,p),{canvas:t,context:f,canvasId:c,contextId:p}}catch(t){throw t}},mouseEnterChecked(t,e){const o=this.getCanvas(),s=o.offsetLeft,i=o.offsetTop,n={x:t-s,y:e-i};let r=[];const l=this.graph.polygon;for(let t in l){const e=l[t];let o=e.points,s=isPointInPolygon(n,o);s&&e.operability&&r.push(e)}const a=this.graph.circle;for(let o in a){let s=a[o];const i=distance({x:s.x,y:s.y},{x:t,y:e});i<=s.r&&s.operability&&r.push(s)}const h=r.length;switch(h){case 0:return null;case 1:return r[0];default:return r.sort((t,e)=>e.index-t.index)[0]}},distanceToLine(t,e,o,s,i){let n=Math.abs(o*t+s*e+i),r=Math.sqrt(o*o+s*s),l=n/r;return l}},LINE={getDeltaX(t,e,o,s){t+=random(.25,.75)*random(-1,1),e+=random(.25,.75)*random(-1,1);const i=random(t,e)-t,n=e-t,r=Math.abs(i/n);return r<o||r>s?this.getDeltaX(t,e,o,s):t+i},bezierLineStage2(t,e,o){const[s,i,n,r,l,a]=t,h=o||this.ctx;h.save(),h.beginPath(),h.moveTo(s,i),h.quadraticCurveTo(n,r,l,a),h.strokeStyle=e||this.colors.side,h.stroke(),h.restore()},bezierLineStage3(t,e,o){const[s,i,n,r,l,a,h,c]=t,p=o||this.ctx;p.save(),p.beginPath(),p.moveTo(s,i),p.bezierCurveTo(n,r,l,a,h,c),p.strokeStyle=e||this.colors.side,p.stroke(),p.closePath(),p.restore()},calculateLine(t,e,o,s,i,n,r){const l=slopeOffset(t,e,o,s),a=t+random(-i,i),h=e+random(-i,i),c=o+random(-i,i),p=s+random(-i,i),y=i/4,f=i/3,d=this.getDeltaX(a,c,y/2,y),x=random(100,250)/1e3,m=l+l*x*random(-1,1),u=h+m*(d-a),g=this.getDeltaX(d,c,f/2,f),P=random(100,250)/1e3,C=l+l*P*random(-1,1),M=u+C*(g-d);return this.bezierLineStage3([a,h,d,u,g,M,c,p],n,r),[a,h,d,u,g,M,c,p]},initLinePath(t,e){let{path:o,offset:s=2,color:i,type:n="line",double:r=!0,id:l,lineType:a="side"}=t;if(!o||o.length<2)console.warn(`{function initLinePath} => ${JSON.stringify(o)}' : 请输入正确的路径 => [{x,y}, {x,y}]`);else{let h=[];s=0==s?1:s;for(let c=0;c<o.length;c++){const p=o[c],y=o[c+1];if(p&&y)if("line"==n){const o=this.createLine({p1:p,p2:y,offset:s,color:i||this.colors.line,double:!t.hasOwnProperty("double")||r,context:e});this.lines.push(o),h.push(o)}else{const o=this.createLine({p1:p,p2:y,offset:s,color:i||this.colors.line,double:!t.hasOwnProperty("double")||r,lineType:a,context:e});let h=this.getGraph(n,l);h.lines||(h.lines=[]),h.lines.push(o)}if(!y){if("line"==n&&2==o.length)return h[0];if("line"==n&&o.length>2)return h}}}},createLine(t){const{p1:e,p2:o,offset:s,color:i,double:n=!0,lineType:r,context:l}=t,{x:a,y:h}=e,{x:c,y:p}=o;let y=[],f=this.calculateLine(a,h,c,p,s,i,l);if(y.push(f),n){let t=this.calculateLine(a,h,c,p,s,i,l);y.push(t)}return{path:y,color:i,points:[e,o],lineType:r,id:`line--id--${randomId()}`}},refreshLine(t,e,o,s=!1){let i=t.zoomPath||t.path;s&&console.warn(t,e),i.map(s=>{this.bezierLineStage3(s,e||t.color,t.context||o)})},refreshAllLine(t){for(let e in this.lines){const o=this.lines[e];o.id!=t&&this.refreshLine(o)}},getLinePoint(t){const e=t.path;let o=[];return e.map(t=>{const e=t.length/2;let s=[];for(let o=0;o<e;o++)s.push({x:t[2*o],y:t[2*o+1]});o.push(s)}),o},updatePath(t,e,o){let s=[];return t.map(t=>{let i=[];t.map((t,s)=>{let n=t;n+=s%2==0?e:o,i.push(n)}),s.push(i)}),s},updateLineInMove(t,e,o){const s=this.updatePath(t.path,e,o);t.path=s;const i=this.updatePath(t.zoomPath,e,o);t.path=s,t.zoomPath=i},updateLineInZoom(t,e,o){const s=this.getLinePoint(t);let i=[];const[n,r]=t.points,l=o?o.x:(n.x+r.x)/2,a=o?o.y:(n.y+r.y)/2;s.map(t=>{let o=[];t.map(t=>{let{x:s,y:i}=this.scaleCommon({targetPoint:t,referPoint:{x:l,y:a},targetRate:e});o.push(s,i)}),i.push(o)}),t.zoomPath=i},setLineRealZoom(t,e,o){t.zoom=e||t.zoom,t.path=o||t.zoomPath,t.zoomPath=null}},GRAPH={createPolygon(t,e){let{dots:o,fillType:s="fill",id:i,offset:n=2,operability:r=!0,colors:l={},pitchColors:a={},double:h=!0,fillDeg:c=0,fillGap:p=10}=t,y=[...o,o[0]];const f=i||`polygon_${Math.random().toString(32).slice(-8)}`;let d=this.getGraph("polygon",f);d.points.push(...o);const x=o.map(t=>t.x),m=o.map(t=>t.y),{x:u,y:g}=this.getPointsCenter(o);let P=Math.abs(Math.max(...x)-Math.min(...x)),C=Math.abs(Math.max(...m)-Math.min(...m));return d.type="polygon",d.operability=r,d.x=u,d.y=g,d.fillType=s,d.fillDeg=["line","mix"].includes(s)?c:0,p=p<=0?1:p,d.fillGap=["line","mix"].includes(s)?p:0,d.crossInit=!1,d.width=P,d.height=C,d.double=!t.hasOwnProperty("double")||h,d.colors={...this.colors,...l},d.pitchColors={...this.pitchColors,...a},d.context=e||this.ctx,this.fillPolygon(d),this.initLinePath({path:y,offset:n,color:d.colors.side,type:"polygon",double:d.double,id:f}),d},createRect(t,e){const{position:o}=t;let s=t;const[i,n,r,l]=o,a={x:i,y:n},h={x:i+r,y:n},c={x:i+r,y:n+l},p={x:i,y:n+l};return s.dots=[a,h,c,p],delete s.position,this.createPolygon(s,e)},fillPolygon(t){let{fillType:e}=t;if("fill"==e||"mix"==e){const e=t.onpitch?t.pitchColors.fill:t.colors.fill,o=t.context;if(o.save(),o.beginPath(),"polygon"===t.type){const e=t.zoomPoints||t.points;e.map((t,e)=>{0==e?o.moveTo(t.x,t.y):o.lineTo(t.x,t.y)}),o.lineTo(e[0].x,e[0].y)}else if("circle"==t.type){const e=t.r*t.zoom;o.arc(t.x,t.y,e,0,2*Math.PI)}o.closePath(),o.fillStyle=e,o.fill(),o.restore()}if("line"==e||"mix"==e){const e=t.onpitch?t.pitchColors.line:t.colors.line;t.crossInit?"circle"==t.type&&t.lines.map(o=>{this.refreshLine(o,e,t.context)}):this.initCrossLine(t,e)}},getPointsCenter(t){const e=t.map(t=>t.x),o=t.map(t=>t.y);let s=e.reduce((t,e)=>t+e)/e.length,i=o.reduce((t,e)=>t+e)/o.length;return{x:s,y:i}},getGraphCrossDots(t){let e=[],o=t.points,{fillDeg:s,fillGap:i,type:n}=t;s%=180;let r,l,a,h,c=[],p=[];if("polygon"==n)o.map((t,s)=>{const i=t,n=s==o.length-1?o[0]:o[s+1];e.push([i.x,i.y,n.x,n.y])}),e.map(t=>{c.push(t[0],t[2]),p.push(t[1],t[3])}),r=Math.min(...c)-5,l=Math.max(...c)+5,a=Math.min(...p)-5,h=Math.max(...p)+5;else if("circle"==n){const{x:e,y:o,r:s}=t;r=e-s-5,l=e+s+5,a=o-s-5,h=o+s+5}let y=[];y=this.getScanLines(l,a,r,h,s,i);let f=[];if(y.map(o=>{let s=[];if("polygon"==n)for(let t=0;t<e.length;t++){const i=e[t],[n,r,l,a]=o,[h,c,p,y]=i,f=calculateIntersection({x:n,y:r},{x:l,y:a},{x:h,y:c},{x:p,y:y});f&&s.push(f)}else if("circle"==n){const[e,i,n,r]=o,{x:l,y:a,r:h}=t,c={x:l,y:a,r:h},p=this.getArcLineCrossDots(c,{x:e,y:i},{x:n,y:r});p&&s.push(...p)}s&&s.length&&f.push(s)}),"circle"==n){let t=[];for(let e=0;e<f.length;e++){const o=[f[e][0],f[f.length-1-e][1]];t.push(o)}f=t}return f},getScanLines(t,e,o,s,i,n){const r=i*(Math.PI/180);let l=n/Math.cos(r),a=n/Math.sin(r),h=[];if(0==i){const i=Math.ceil((s-e)/n);for(let s=0;s<i;s++){let i=o,r=e+s*n,l=t,a=e+s*n;h.push([i,r,l,a])}}else if(90==i){const i=Math.ceil((t-o)/n);for(let t=0;t<i;t++){let i=o+t*n,r=e,l=o+t*n,a=s;h.push([i,r,l,a])}}else if(i<90){const i=Math.tan(r);let c=e-i*t;const p=Math.ceil(this.distanceToLine(o,s,i,-1,c)/n);for(let t=p;t>0;t--){let e=o,i=s-t*l,n=t*a+o,r=s;h.push([e,i,n,r])}}else{const i=Math.tan(r);let c=e-i*o;const p=Math.ceil(this.distanceToLine(t,s,i,-1,c)/n);for(let e=p;e>0;e--){let o=t,i=s+e*l,n=t-e*a,r=s;h.push([o,i,n,r])}}return h},initCrossLine(t,e){const o=this.getGraphCrossDots(t);t.crossDots=o,t.crossDots&&t.crossDots.length&&(t.crossInit=!0,t.crossDots.map(o=>{2==o.length&&this.initLinePath({path:o,offset:2,color:e,type:t.type,double:!t.hasOwnProperty("double")||t.double,id:t.id,lineType:"fill"})}))},updateGraphZoom(t,e,o){let s={};"polygon"==t.type&&(s=this.getPointsCenter(t.points)),"circle"==t.type&&(s={x:t.x,y:t.y});const i=o?o.x:s.x,n=o?o.y:s.y;let r={x:i,y:n};this.zoomPointsFn(t,e),t.lines.map(t=>{this.updateLineInZoom(t,e,r)})},zoomPointsFn(t,e){let o={};if("polygon"==t.type&&(o=this.getPointsCenter(t.points)),"circle"==t.type){o={x:t.x,y:t.y};const s={x:t.offset.startX,y:t.offset.startY},i={x:t.offset.endX,y:t.offset.endY},n=this.scaleCommon({targetPoint:s,referPoint:o,targetRate:e}),r=this.scaleCommon({targetPoint:i,referPoint:o,targetRate:e});t.zoomOffset={startX:n.x,startY:n.y,endX:r.x,endY:r.y}}let s=[];t.points.map(t=>{let i=this.scaleCommon({targetPoint:t,referPoint:o,targetRate:e});s.push(i)}),t.zoom=e,t.zoomPoints=s},updateGraphMove(t,e,o){t.x+=e,t.y+=o,t.lines.map(t=>{this.updateLineInMove(t,e,o)}),"circle"==t.type&&(t.offset.startX+=e,t.offset.endX+=e,t.offset.startY+=o,t.offset.endY+=o,t.zoomOffset.startX+=e,t.zoomOffset.endX+=e,t.zoomOffset.startY+=o,t.zoomOffset.endY+=o),t.points.map(t=>{t.x+=e,t.y+=o}),t.zoomPoints&&t.zoomPoints.map(t=>{t.x+=e,t.y+=o})},refreshGraph(t,e=[],o=!1){o&&console.warn(t,e),this.fillPolygon(t);let s="";t.lines.map(e=>{s="fill"==e.lineType?t.onpitch?t.pitchColors.line:t.colors.line:t.onpitch?t.pitchColors.side:t.colors.side,this.refreshLine(e,s,t.context,o)})},refreshAllGraph(t){const e=this.graph.polygon;for(let o in e){const s=e[o];t!=s.id&&this.refreshGraph(s)}},initGraphStatus(t,e=[]){const o=this.graphStatus.filter(t=>!e.includes(t));o.map(e=>{t[e]=!1,this.activeStatus.includes(e)&&this.activeGraph[e][t.id]&&this.removeActiveGraph(e,t.id)})},initAllGraphStatus(){for(let t in this.activeGraph){let e=this.activeGraph[t];e.map(t=>{this.initGraphStatus(t)})}},addActiveGraph(t,e){this.activeGraph[t][e.id]||(this.activeGraph[t][e.id]=e)},removeActiveGraph(t,e){this.activeGraph[t][e]&&delete this.activeGraph[t][e]},move(t,e,o){t.onpitch&&(this.addActiveGraph("onmove",t),this.updateGraphMove(t,e,o))}},CIRCLE={getPointOnCircle(t,e){let o=t*(Math.PI/180),s=e.x+e.r*Math.cos(o),i=e.y+e.r*Math.sin(o);return{x:s,y:i}},createCircle(t,e){let{x:o,y:s,r:i,id:n,operability:r=!0,colors:l={},pitchColors:a={},fillType:h="fill",double:c=!0,fillDeg:p=0,fillGap:y=10}=t,f=`circle_${n||Math.random().toString(32).slice(-8)}`,d=this.getGraph("circle",f);d.x=o,d.y=s,d.r=i,d.colors={...this.colors,...l},d.pitchColors={...this.pitchColors,...a},d.type="circle",d.context=e||this.ctx,d.fillType=h,d.operability=r,d.fillDeg=["line","mix"].includes(h)?p:0,y=y<=0?1:y,d.fillGap=["line","mix"].includes(h)?y:0,d.crossInit=!1,d.double=!t.hasOwnProperty("double")||c;let x=o+random(-2,2),m=s+random(-2,2);const u=this.calculateCirDots(x,m,i);d.points=[],d.points.push(...u);let g=8;if(d.double){let t=o+random(-2,2),e=s+random(-2,2);const n=this.calculateCirDots(t,e,i);d.points.push(...n),g=16}d.len=g;const P={startX:d.points[0].x+random(-5,5),startY:d.points[0].y+random(-20,0),endX:d.points[g-1].x+random(-5,5),endY:d.points[g-1].y+random(0,20)};return d.offset=P,this.drawCir(d),d},drawCir(t){const e=t.zoomPoints||t.points,o=e.length,s=t.context,{startX:i,startY:n,endX:r,endY:l}=t.zoomOffset||t.offset;this.fillPolygon(t);for(let a=0;a<o;a+=2){let h=e[a],c=e[a+1],p=a==o-2?e[0]:e[a+2];s.save(),s.beginPath(),0==a?s.moveTo(i,n):s.moveTo(h.x,h.y),a==o-1?s.quadraticCurveTo(c.x,c.y,r,l):s.quadraticCurveTo(c.x,c.y,p.x,p.y);const y=t.onpitch?t.pitchColors.side:t.colors.side;s.strokeStyle=y,s.stroke(),s.restore()}},refreshAllCircles(t){const e=this.graph.circle;for(let o in e){const s=e[o];t!=s.id&&this.drawCir(s)}},getLineCirCrossX(t,e,o,s,i){let n=(i*i-t*t-Math.pow(o-e,2))*(1+s*s)+Math.pow(o*s-t-e*s,2),r=(Math.sqrt(n)-o*s+t+e*s)/(1+s*s);return r},getArcLineCrossDots(t,e,o){let s=slope(e.x,e.y,o.x,o.y),i=e.y-s*e.x;const n=Math.abs(i)==1/0,r=n?Math.abs(e.x-t.x):this.distanceToLine(t.x,t.y,s,-1,i);if(r<t.r){let o=n?e.x:this.getLineCirCrossX(t.x,t.y,i,s,t.r),r=n?Math.sqrt(t.r*t.r-Math.pow(o-t.x,2))+t.y:s*o+i,l=o-t.x,a=r-t.y;return[{x:o,y:r},{x:t.x-l,y:t.y-a}]}},calculateCirDots(t,e,o){let s={x:t,y:e,r:o};const i=8;let n=[];const r=random(.32,.38)+1;for(let t=0;t<i;t++){const e=360*t/i,o={...s,r:s.r*r},l=t%2?this.getPointOnCircle(e,o):this.getPointOnCircle(e,s);let a=random(-3,3),h=random(-3,3),c=l.x+a,p=l.y+h;n.push({x:c,y:p})}return n}},FUNCTIONS={...COMMON,...LINE,...GRAPH,...CIRCLE};HandDraw.prototype.constructor=HandDraw;for(let t in FUNCTIONS)HandDraw.prototype[t]=FUNCTIONS[t];