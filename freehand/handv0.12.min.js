function hexToHsl(t,e=1){var o,s=t.replace("#","").match(/[0-9a-f]{2}/g),i=parseInt(s[0],16)/255,n=parseInt(s[1],16)/255,l=parseInt(s[2],16)/255,r=Math.max(i,n,l),a=Math.min(i,n,l),h=i===r?0:n===r?1:2,c=i===a?0:n===a?1:2;if(r===a)o=0;else{switch(h-c){case 0:o=(n-l)/(r-a)*60;break;case 1:o=(n-i)/(r-a)*60+120;break;case 2:o=(l-n)/(r-a)*60+240}o<0&&(o+=360)}var p=0!==r&&1!==r?((r-a)/r*100).toFixed():0,y=(r+a)/2*100;return 1==e?`hsl(${o}, ${p}%, ${y}%)`:[o,p,y]}function hslToHex(t){let e,o,s;if(Array.isArray(t))[e,o,s]=t;else{const i=t,n=t.indexOf("(")+1,l=t.indexOf(")"),r=i.substring(n,l).split(",");e=+r[0].trim()/360,[o,s]=r.filter((t,e)=>e).map(t=>+t.trim().split("%")[0]/100)}var i,n,l;if(console.log(e,o,s),0===o)i=n=l=255*s;else{var r=function(t,e,o){return o<0&&(o+=1),o>1&&(o-=1),o<1/6?t+6*(e-t)*o:o<.5?e:o<2/3?t+(e-t)*(2/3-o)*6:t},a=s<.5?s*(1+o):s+o-s*o;t=2*s-a;i=r(t,a,e+1/3),n=r(t,a,e),l=r(t,a,e-1/3)}return i=Math.round(255*i).toString(16),n=Math.round(255*n).toString(16),l=Math.round(255*l).toString(16),i=1===i.length?"0"+i:i,n=1===n.length?"0"+n:n,l=1===l.length?"0"+l:l,"#"+i+n+l}function multiply(t,e,o){let s=e[0],i=e[1],n=e[2],l=e[3],r=e[4],a=e[5],h=e[6],c=e[7],p=e[8],y=e[9],f=e[10],d=e[11],x=e[12],m=e[13],u=e[14],g=e[15],P=o[0],C=o[1],v=o[2],M=o[3];return t[0]=P*s+C*r+v*p+M*x,t[1]=P*i+C*a+v*y+M*m,t[2]=P*n+C*h+v*f+M*u,t[3]=P*l+C*c+v*d+M*g,P=o[4],C=o[5],v=o[6],M=o[7],t[4]=P*s+C*r+v*p+M*x,t[5]=P*i+C*a+v*y+M*m,t[6]=P*n+C*h+v*f+M*u,t[7]=P*l+C*c+v*d+M*g,P=o[8],C=o[9],v=o[10],M=o[11],t[8]=P*s+C*r+v*p+M*x,t[9]=P*i+C*a+v*y+M*m,t[10]=P*n+C*h+v*f+M*u,t[11]=P*l+C*c+v*d+M*g,P=o[12],C=o[13],v=o[14],M=o[15],t[12]=P*s+C*r+v*p+M*x,t[13]=P*i+C*a+v*y+M*m,t[14]=P*n+C*h+v*f+M*u,t[15]=P*l+C*c+v*d+M*g,t}function calculateIntersection(t,e,o,s){let i=(t.x-o.x)*(e.y-o.y)-(t.y-o.y)*(e.x-o.x),n=(t.x-s.x)*(e.y-s.y)-(t.y-s.y)*(e.x-s.x);if(i*n>=0)return!1;let l=(o.x-t.x)*(s.y-t.y)-(o.y-t.y)*(s.x-t.x),r=l+i-n;if(l*r>=0)return!1;let a=l/(n-i),h=a*(e.x-t.x),c=a*(e.y-t.y);return{x:t.x+h,y:t.y+c}}function throttle(t,e){let o;return function(){let s=this,i=arguments;o||(o=setTimeout(function(){o=null,t.apply(s,i)},e))}}const random=function(t,e){if(arguments.length<2&&(e=t,t=0),t>e){let o=e;e=t,t=o}const o=+t%1!=0||+e%1!=0;return o&&(t*=1e8,e*=1e8),(Math.floor(Math.random()*(e-t+1))+t)/(o?1e8:1)},randomId=()=>Math.random().toString(32).slice(-8),isPointInPolygon=(t,e,o)=>{if(!e||!t)return!1;let s,i,n=e.length,l=!0,r=0,a=2e-10,h=t;s=e[0];for(let t=1;t<=n;++t){if(h.x==s.x&&h.y==s.y)return l;if(i=e[t%n],h.y<Math.min(s.y,i.y)||h.y>Math.max(s.y,i.y))s=i;else{if(h.y>Math.min(s.y,i.y)&&h.y<Math.max(s.y,i.y)){if(h.x<=Math.max(s.x,i.x)){if(s.y==i.y&&h.x>=Math.min(s.x,i.x))return l;if(s.x==i.x){if(s.x==h.x)return l;++r}else{let t=(h.y-s.y)*(i.x-s.x)/(i.y-s.y)+s.x;if(Math.abs(h.x-t)<a)return l;h.x<t&&++r}}}else if(h.y==i.y&&h.x<=i.x){let o=e[(t+1)%n];h.y>=Math.min(s.y,o.y)&&h.y<=Math.max(s.y,o.y)?++r:r+=2}s=i}}return r%2!=0},distance=(t,e)=>Math.sqrt((e.x-t.x)*(e.x-t.x)+(e.y-t.y)*(e.y-t.y)),slopeOffset=(t,e,o,s)=>t==o?random(5,50)/1e3:(s-e)/(o-t),slope=(t,e,o,s)=>(s-e)/(o-t),decimals=t=>+t%1,$isDOM=t=>"function"==typeof HTMLElement?t instanceof HTMLElement:t&&"object"==typeof t&&1===t.nodeType&&"string"==typeof t.nodeName,$=t=>{const e=document.querySelectorAll(t);return 1===e.length?e[0]:Array.from(e)};class HandDraw{constructor(t){const{x:e,y:o,width:s,height:i,el:n,zIndex:l,id:r,classname:a,colors:h={},pitchColors:c={}}=t,p=document.createElement("canvas"),y=r||randomId(),f=`canvas_id_${y}`,d=`ctx_id_${y}`,x=p.getContext("2d");p.setAttribute("id",f),p.style.position="absolute",p.style.zIndex=l,p.style.left=`${e}px`,p.style.top=`${o}px`,p.width=s,p.height=i,a&&p.classList.add(a),this.canvas=p,this.ctx=x,this.canvasSet=new Map,this.contextSet=new Map,this.canvasSet.set(f,p),this.contextSet.set(d,x),this.colors={side:h.side||"#fff",fill:h.fill||"#fff3",line:h.line||"#fff"},this.pitchColors={side:c.side||"#f00",fill:c.fill||"#f003",line:c.line||"#f008"},this.TOTALINDEX=0,this.lines={},this.onRefreshTime=0,this.graph={polygon:{},circle:{},ellipse:{}},this.activeGraph={onmove:{},ontransform:{}},this.graphStatus=["ontransform","onenter","onpitch","onmove","onzoom"],this.activeStatus=["onmove","ontransform"];const m=n?$(n):document.body;m.appendChild(p)}}const COMMON={getCanvas(t){return t?this.canvasSet.get(t):this.canvas},getCtx(t){return t?this.contextSet.get(t):this.ctx},getGraph(t,e,o=""){const s=this.graph[t];let i=s[e];return o&&console.warn(t,e,o),i||(i={},i.index=this.getIndex(),i.id=e,i.zoom=1,i.ontransform=!1,i.onenter=!1,i.onpitch=!1,i.onmove=!1,i.onzoom=!1,i.lines=[],"polygon"==t&&(i.points=[]),s[e]=i),s[e]},getPath(t,e){const o=this.graph[t];return o[e].path},dotin(t,e="#f00",o){const s=o||this.getCtx();s.save();const{x:i,y:n}=t;s.beginPath(),s.strokeStyle=e,s.fillStyle=e,s.arc(i,n,2,0,2*Math.PI),s.stroke(),s.fill(),s.closePath(),s.restore()},rectin(t,e,o,s,i="#00ff00",n){const l=n||this.getCtx();l.save(),l.beginPath(),l.moveTo(t,e),l.lineTo(t+o,e),l.lineTo(t+o,e+s),l.lineTo(t,e+s),l.lineTo(t,e),l.strokeStyle=i,l.stroke(),l.closePath(),l.restore()},getIndex(){return this.TOTALINDEX++,this.TOTALINDEX},clear(){this.ctx.clearRect(0,0,this.canvas.width,this.canvas.height)},scaleCommon(t){let{onlyPoint:e=!0,targetPoint:o,referPoint:s,targetRate:i,width:n,height:l}=t;const{x:r,y:a}=s,{x:h,y:c}=o;let p,y,f,d,x,m,u,g,P,C;n&&l||(e=!0),e?(p=r-r,y=a-a,f=h-r,d=c-a,p>f?(m=f,u=p):(m=p,u=f),y>d?(g=y,x=d):(g=d,x=y),P=p*(1-i),C=y*(1-i)):(m=h,u=h+n,x=c,g=c+l,P=r*(1-i),C=a*(1-i));const v=[m,x,1,1],M=[u,x,1,1],T=[u,g,1,1],L=[m,g,1,1];let b=new Float32Array([...v,...M,...T,...L]);const S=new Float32Array([0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]),I=[i,0,0,0],G=[0,i,0,0],w=[0,0,1,0],z=[P,C,0,1],O=new Float32Array([...I,...G,...w,...z]),D=multiply(S,O,b);if(e){let t,e;return t=p>f?D[0]+r:D[4]+r,e=y>d?D[1]+a:D[9]+a,{x:t,y:e}}return{width:D[4]-D[0],height:D[9]-D[1],left:D[0],right:D[4],top:D[1],bottom:D[9]}},async refresh(t){const e=Date.now(),o=e-this.onRefreshTime;o<16||(this.onRefreshTime=e,this.clear(),this.refreshAllLine(t),this.refreshAllGraph(t),this.refreshAllCircles(t))},createCanvas(t,e){const{x:o,y:s,width:i,height:n,zIndex:l,id:r,classname:a}=t;try{const t=document.createElement("canvas"),h=r||randomId(),c=`canvas_id_${h}`,p=`ctx_id_${h}`,y=t.getContext("2d");this.canvasSet.set(c,t),this.contextSet.set(p,y),t.style.position="absolute",t.style.zIndex=l,t.style.left=`${o}px`,t.style.top=`${s}px`,t.width=i,t.height=n,a&&t.classList.add(a);const f=t.getContext("2d");return"function"==typeof e&&e(t,f,c,p),{canvas:t,context:f,canvasId:c,contextId:p}}catch(t){throw t}},mouseEnterChecked(t,e){const o=this.getCanvas(),s=o.offsetLeft,i=o.offsetTop,n={x:t-s,y:e-i};let l=[];const r=this.graph.polygon;for(let t in r){const e=r[t];let o=e.points,s=isPointInPolygon(n,o);s&&e.operability&&l.push(e)}const a=this.graph.circle;for(let o in a){let s=a[o];const i=distance({x:s.x,y:s.y},{x:t,y:e});i<=s.r&&s.operability&&l.push(s)}const h=l.length;switch(h){case 0:return null;case 1:return l[0];default:return l.sort((t,e)=>e.index-t.index)[0]}},setLinesColor(t){this.colors.line=t;for(let e in this.lines){let o=this.lines[e];o.color=t}},setLineColor(t,e){e.color=t},setGraphLinesColor(t,e){e.colors||(e.colors={}),e.colors.line=t;for(let o in e.lines){let s=e.lines[o];"fill"==s.lineType&&(s.color=t)}},setSideColor(t){this.colors.side=t},setGraphSideColor(t,e){e.colors||(e.colors={}),e.colors.side=t;for(let o in e.lines){let s=e.lines[o];"side"==s.lineType&&(s.color=t)}},setFillColor(t){this.colors.fill=t},setGraphFillColor(t,e){e.colors||(e.colors={}),e.colors.fill=t},distanceToLine(t,e,o,s,i){let n=Math.abs(o*t+s*e+i),l=Math.sqrt(o*o+s*s),r=n/l;return r}},LINE={getDeltaX(t,e,o,s){t+=random(.25,.75)*random(-1,1),e+=random(.25,.75)*random(-1,1);const i=random(t,e)-t,n=e-t,l=Math.abs(i/n);return l<o||l>s?this.getDeltaX(t,e,o,s):t+i},bezierLineStage2(t,e,o){const[s,i,n,l,r,a]=t,h=o||this.ctx;h.save(),h.beginPath(),h.moveTo(s,i),h.quadraticCurveTo(n,l,r,a),h.strokeStyle=e||this.colors.side,h.stroke(),h.restore()},bezierLineStage3(t,e,o){const[s,i,n,l,r,a,h,c]=t,p=o||this.ctx;p.save(),p.beginPath(),p.moveTo(s,i),p.bezierCurveTo(n,l,r,a,h,c),p.strokeStyle=e,p.stroke(),p.closePath(),p.restore()},calculateLine(t,e,o,s,i,n,l){const r=slopeOffset(t,e,o,s),a=t+random(-i,i),h=e+random(-i,i),c=o+random(-i,i),p=s+random(-i,i),y=i/4,f=i/3,d=this.getDeltaX(a,c,y/2,y),x=random(100,250)/1e3,m=r+r*x*random(-1,1),u=h+m*(d-a),g=this.getDeltaX(d,c,f/2,f),P=random(100,250)/1e3,C=r+r*P*random(-1,1),v=u+C*(g-d);return this.bezierLineStage3([a,h,d,u,g,v,c,p],n,l),[a,h,d,u,g,v,c,p]},initLinePath(t,e){let{path:o,offset:s=2,color:i,type:n="line",double:l=!0,id:r,lineType:a="side"}=t;if(!o||o.length<2)console.warn(`{function initLinePath} => ${JSON.stringify(o)}' : 请输入正确的路径 => [{x,y}, {x,y}]`);else{let h={};s=0==s?1:s;for(let c=0;c<o.length;c++){const p=o[c],y=o[c+1];if(p&&y)if("line"==n){const o=this.createLine({p1:p,p2:y,offset:s,color:i||("side"==a?this.colors.side:this.colors.line),double:!t.hasOwnProperty("double")||l,context:e}),n=o.id;this.lines[n]=o,h[n]=o}else{const o=this.createLine({p1:p,p2:y,offset:s,color:i||("side"==a?this.colors.side:this.colors.line),double:!t.hasOwnProperty("double")||l,lineType:a,context:e});let h=this.getGraph(n,r);h.lines||(h.lines=[]),h.lines.push(o)}if(!y&&"line"==n)return h}}},createLine(t){const{p1:e,p2:o,offset:s,color:i,double:n=!0,lineType:l,context:r}=t,{x:a,y:h}=e,{x:c,y:p}=o;let y=[],f=this.calculateLine(a,h,c,p,s,i,r);if(y.push(f),n){let t=this.calculateLine(a,h,c,p,s,i,r);y.push(t)}return{path:y,color:i,points:[e,o],lineType:l,id:`line_${randomId()}`}},refreshLine(t,e,o,s=!1){let i=t.zoomPath||t.path;s&&console.warn(t,e),i.map(s=>{this.bezierLineStage3(s,e||t.color,t.context||o)})},refreshAllLine(t){for(let e in this.lines){const o=this.lines[e];o.id!=t&&this.refreshLine(o)}},getLinePoint(t){const e=t.path;let o=[];return e.map(t=>{const e=t.length/2;let s=[];for(let o=0;o<e;o++)s.push({x:t[2*o],y:t[2*o+1]});o.push(s)}),o},updatePath(t,e,o){let s=[];return t.map(t=>{let i=[];t.map((t,s)=>{let n=t;n+=s%2==0?e:o,i.push(n)}),s.push(i)}),s},updateLineInMove(t,e,o){const s=this.updatePath(t.path,e,o);t.path=s;const i=this.updatePath(t.zoomPath,e,o);t.path=s,t.zoomPath=i},updateLineInZoom(t,e,o){const s=this.getLinePoint(t);let i=[];const[n,l]=t.points,r=o?o.x:(n.x+l.x)/2,a=o?o.y:(n.y+l.y)/2;s.map(t=>{let o=[];t.map(t=>{let{x:s,y:i}=this.scaleCommon({targetPoint:t,referPoint:{x:r,y:a},targetRate:e});o.push(s,i)}),i.push(o)}),t.zoomPath=i},setLineRealZoom(t,e,o){t.zoom=e||t.zoom,t.path=o||t.zoomPath,t.zoomPath=null}},GRAPH={createPolygon(t,e){let{dots:o,fillType:s="fill",id:i,offset:n=2,operability:l=!0,colors:r={},pitchColors:a={},double:h=!0,fillDeg:c=0,fillGap:p=10}=t,y=[...o,o[0]];const f=i||`polygon_${Math.random().toString(32).slice(-8)}`;let d=this.getGraph("polygon",f);d.points.push(...o);const x=o.map(t=>t.x),m=o.map(t=>t.y),{x:u,y:g}=this.getPointsCenter(o);let P=Math.abs(Math.max(...x)-Math.min(...x)),C=Math.abs(Math.max(...m)-Math.min(...m));return d.type="polygon",d.operability=l,d.x=u,d.y=g,d.fillType=s,d.fillDeg=["line","mix"].includes(s)?c:0,p=p<=0?1:p,d.fillGap=["line","mix"].includes(s)?p:0,d.crossInit=!1,d.width=P,d.height=C,d.double=!t.hasOwnProperty("double")||h,d.colors={...this.colors,...r},d.pitchColors={...this.pitchColors,...a},d.context=e||this.ctx,this.fillPolygon(d),this.initLinePath({path:y,offset:n,color:d.colors.side,type:"polygon",double:d.double,id:f}),d},createRect(t,e){const{position:o}=t;let s=t;const[i,n,l,r]=o,a={x:i,y:n},h={x:i+l,y:n},c={x:i+l,y:n+r},p={x:i,y:n+r};return s.dots=[a,h,c,p],delete s.position,this.createPolygon(s,e)},fillPolygon(t){let{fillType:e}=t;if("fill"==e||"mix"==e){const e=t.onpitch?t.pitchColors.fill:t.colors.fill,o=t.context;if(o.save(),o.beginPath(),"polygon"===t.type){const e=t.zoomPoints||t.points;e.map((t,e)=>{0==e?o.moveTo(t.x,t.y):o.lineTo(t.x,t.y)}),o.lineTo(e[0].x,e[0].y)}else if("circle"==t.type){const e=t.r*t.zoom;o.arc(t.x,t.y,e,0,2*Math.PI)}o.closePath(),o.fillStyle=e,o.fill(),o.restore()}if("line"==e||"mix"==e){const e=t.onpitch?t.pitchColors.line:t.colors.line;t.crossInit?"circle"==t.type&&t.lines.map(o=>{this.refreshLine(o,e,t.context)}):this.initCrossLine(t,e)}},getPointsCenter(t){const e=t.map(t=>t.x),o=t.map(t=>t.y);let s=e.reduce((t,e)=>t+e)/e.length,i=o.reduce((t,e)=>t+e)/o.length;return{x:s,y:i}},getGraphCrossDots(t){let e=[],o=t.points,{fillDeg:s,fillGap:i,type:n}=t;s%=180;let l,r,a,h,c=[],p=[];if("polygon"==n)o.map((t,s)=>{const i=t,n=s==o.length-1?o[0]:o[s+1];e.push([i.x,i.y,n.x,n.y])}),e.map(t=>{c.push(t[0],t[2]),p.push(t[1],t[3])}),l=Math.min(...c)-5,r=Math.max(...c)+5,a=Math.min(...p)-5,h=Math.max(...p)+5;else if("circle"==n){const{x:e,y:o,r:s}=t;l=e-s-5,r=e+s+5,a=o-s-5,h=o+s+5}let y=[];y=this.getScanLines(r,a,l,h,s,i),console.log(y);let f=[];if((()=>{const t=this.ctx;y.map(e=>{const[o,s,i,n]=e;t.save(),t.beginPath(),t.moveTo(o,s),t.lineTo(i,n),t.closePath(),t.strokeStyle="#f00",t.stroke(),t.restore()}),t.save(),t.beginPath(),t.moveTo(l,a),t.lineTo(r,a),t.lineTo(r,h),t.lineTo(l,h),t.lineTo(l,a),t.closePath(),t.strokeStyle="#0f0",t.stroke(),t.restore()})(),y.map(o=>{let s=[];if("polygon"==n)for(let t=0;t<e.length;t++){const i=e[t],[n,l,r,a]=o,[h,c,p,y]=i,f=calculateIntersection({x:n,y:l},{x:r,y:a},{x:h,y:c},{x:p,y:y});f&&s.push(f)}else if("circle"==n){const[e,i,n,l]=o,{x:r,y:a,r:h}=t,c={x:r,y:a,r:h},p=this.getArcLineCrossDots(c,{x:e,y:i},{x:n,y:l});p&&s.push(...p)}s&&s.length&&f.push(s)}),"circle"==n){let t=[];for(let e=0;e<f.length;e++){const o=[f[e][0],f[f.length-1-e][1]];t.push(o)}f=t}return f},getScanLines(t,e,o,s,i,n){const l=i*(Math.PI/180);let r=n/Math.cos(l),a=n/Math.sin(l),h=[];if(0==i){const i=Math.ceil((s-e)/n);for(let s=0;s<i;s++){let i=o,l=e+s*n,r=t,a=e+s*n;h.push([i,l,r,a])}}else if(90==i){const i=Math.ceil((t-o)/n);for(let t=0;t<i;t++){let i=o+t*n,l=e,r=o+t*n,a=s;h.push([i,l,r,a])}}else if(i<90){const i=Math.tan(l);let c=e-i*t;const p=Math.ceil(this.distanceToLine(o,s,i,-1,c)/n);for(let t=p;t>0;t--){let e=o,i=s-t*r,n=t*a+o,l=s;h.push([e,i,n,l])}}else{const i=Math.tan(l);let c=e-i*o;const p=Math.ceil(this.distanceToLine(t,s,i,-1,c)/n);for(let e=p;e>0;e--){let o=t,i=s+e*r,n=t-e*a,l=s;h.push([o,i,n,l])}}return h},initCrossLine(t,e){const o=this.getGraphCrossDots(t);t.crossDots=o,t.crossDots&&t.crossDots.length&&(t.crossInit=!0,t.crossDots.map(o=>{2==o.length&&this.initLinePath({path:o,offset:2,color:e,type:t.type,double:!t.hasOwnProperty("double")||t.double,id:t.id,lineType:"fill"})}))},updateGraphZoom(t,e,o){let s={};"polygon"==t.type&&(s=this.getPointsCenter(t.points)),"circle"==t.type&&(s={x:t.x,y:t.y});const i=o?o.x:s.x,n=o?o.y:s.y;let l={x:i,y:n};this.zoomPointsFn(t,e),t.lines.map(t=>{this.updateLineInZoom(t,e,l)})},zoomPointsFn(t,e){let o={};if("polygon"==t.type&&(o=this.getPointsCenter(t.points)),"circle"==t.type){o={x:t.x,y:t.y};const s={x:t.offset.startX,y:t.offset.startY},i={x:t.offset.endX,y:t.offset.endY},n=this.scaleCommon({targetPoint:s,referPoint:o,targetRate:e}),l=this.scaleCommon({targetPoint:i,referPoint:o,targetRate:e});t.zoomOffset={startX:n.x,startY:n.y,endX:l.x,endY:l.y}}let s=[];t.points.map(t=>{let i=this.scaleCommon({targetPoint:t,referPoint:o,targetRate:e});s.push(i)}),t.zoom=e,t.zoomPoints=s},updateGraphMove(t,e,o){t.x+=e,t.y+=o,t.lines.map(t=>{this.updateLineInMove(t,e,o)}),"circle"==t.type&&(t.offset.startX+=e,t.offset.endX+=e,t.offset.startY+=o,t.offset.endY+=o,t.zoomOffset.startX+=e,t.zoomOffset.endX+=e,t.zoomOffset.startY+=o,t.zoomOffset.endY+=o),t.points.map(t=>{t.x+=e,t.y+=o}),t.zoomPoints&&t.zoomPoints.map(t=>{t.x+=e,t.y+=o})},refreshGraph(t,e=[],o=!1){o&&console.warn(t,e),this.fillPolygon(t);let s="";t.lines.map(e=>{s="fill"==e.lineType?t.onpitch?t.pitchColors.line:t.colors.line:t.onpitch?t.pitchColors.side:t.colors.side,this.refreshLine(e,s,t.context,o)})},refreshAllGraph(t){const e=this.graph.polygon;for(let o in e){const s=e[o];t!=s.id&&this.refreshGraph(s)}},initGraphStatus(t,e=[]){const o=this.graphStatus.filter(t=>!e.includes(t));o.map(e=>{t[e]=!1,this.activeStatus.includes(e)&&this.activeGraph[e][t.id]&&this.removeActiveGraph(e,t.id)})},initAllGraphStatus(){for(let t in this.activeGraph){let e=this.activeGraph[t];e.map(t=>{this.initGraphStatus(t)})}},addActiveGraph(t,e){this.activeGraph[t][e.id]||(this.activeGraph[t][e.id]=e)},removeActiveGraph(t,e){this.activeGraph[t][e]&&delete this.activeGraph[t][e]},move(t,e,o){t.onpitch&&(this.addActiveGraph("onmove",t),this.updateGraphMove(t,e,o))}},CIRCLE={getPointOnCircle(t,e){let o=t*(Math.PI/180),s=e.x+e.r*Math.cos(o),i=e.y+e.r*Math.sin(o);return{x:s,y:i}},createCircle(t,e){let{x:o,y:s,r:i,id:n,operability:l=!0,colors:r={},pitchColors:a={},fillType:h="fill",double:c=!0,fillDeg:p=0,fillGap:y=10}=t,f=`circle_${n||Math.random().toString(32).slice(-8)}`,d=this.getGraph("circle",f);d.x=o,d.y=s,d.r=i,d.colors={...this.colors,...r},d.pitchColors={...this.pitchColors,...a},d.type="circle",d.context=e||this.ctx,d.fillType=h,d.operability=l,d.fillDeg=["line","mix"].includes(h)?p:0,y=y<=0?1:y,d.fillGap=["line","mix"].includes(h)?y:0,d.crossInit=!1,d.double=!t.hasOwnProperty("double")||c;let x=o+random(-2,2),m=s+random(-2,2);const u=this.calculateCirDots(x,m,i);d.points=[],d.points.push(...u);let g=8;if(d.double){let t=o+random(-2,2),e=s+random(-2,2);const n=this.calculateCirDots(t,e,i);d.points.push(...n),g=16}d.len=g;const P={startX:d.points[0].x+random(-5,5),startY:d.points[0].y+random(-10,10),endX:d.points[g-1].x+random(-5,5),endY:d.points[g-1].y+random(-10,10)};return d.offset=P,this.drawCir(d),d},drawCir(t){const e=t.zoomPoints||t.points,o=e.length,s=t.context,{startX:i,startY:n,endX:l,endY:r}=t.zoomOffset||t.offset;this.fillPolygon(t);for(let a=0;a<o;a+=2){let h=e[a],c=e[a+1],p=a==o-2?e[0]:e[a+2];s.save(),s.beginPath(),0==a?s.moveTo(i,n):s.moveTo(h.x,h.y),a==o-1?s.quadraticCurveTo(c.x,c.y,l,r):s.quadraticCurveTo(c.x,c.y,p.x,p.y);const y=t.onpitch?t.pitchColors.side:t.colors.side;s.strokeStyle=y,s.stroke(),s.restore()}},refreshAllCircles(t){const e=this.graph.circle;for(let o in e){const s=e[o];t!=s.id&&this.drawCir(s)}},getLineCirCrossX(t,e,o,s,i){let n=(i*i-t*t-Math.pow(o-e,2))*(1+s*s)+Math.pow(o*s-t-e*s,2),l=(Math.sqrt(n)-o*s+t+e*s)/(1+s*s);return l},getArcLineCrossDots(t,e,o){let s=slope(e.x,e.y,o.x,o.y),i=e.y-s*e.x;const n=Math.abs(i)==1/0,l=n?Math.abs(e.x-t.x):this.distanceToLine(t.x,t.y,s,-1,i);if(l<t.r){let o=n?e.x:this.getLineCirCrossX(t.x,t.y,i,s,t.r),l=n?Math.sqrt(t.r*t.r-Math.pow(o-t.x,2))+t.y:s*o+i,r=o-t.x,a=l-t.y;return[{x:o,y:l},{x:t.x-r,y:t.y-a}]}},calculateCirDots(t,e,o){let s={x:t,y:e,r:o};const i=8;let n=[];const l=random(.32,.38)+1;for(let t=0;t<i;t++){const e=360*t/i,o={...s,r:s.r*l},r=t%2?this.getPointOnCircle(e,o):this.getPointOnCircle(e,s);let a=random(-3,3),h=random(-3,3),c=r.x+a,p=r.y+h;n.push({x:c,y:p})}return n}},FUNCTIONS={...COMMON,...LINE,...GRAPH,...CIRCLE};HandDraw.prototype.constructor=HandDraw;for(let t in FUNCTIONS)HandDraw.prototype[t]=FUNCTIONS[t];